Design Principle

General Pourpose:学习设计模式，学习封装Linux API，练习C++
Method：先看书，然后把书放在一边，自己设计，自己实现！（自己做很重要！照着书上敲代码很多时候是敲了也不知道别人为什么那样做！）

CLStatus:
	功能：用来反应函数执行完的状态，包括返回值和出错码。
	为了使得类外部可以直接使用变量名返回出错码 m_lErrorCode, 使用了两个public的const long &引用来实现外部只可以读不可写。
	直接 return CLStatus()对象会减少构造对象的次数，提高效率，故这样写。不要CLStatus A; return A；，这样会增加构造次数。

CLLogger:
	功能：每条日志包含一条日志消息和一个出错码。
	
	Version 0.1：无缓冲
	CLLogger是一个记录程序出错的日志类，需要读写文件。由于一个程序生命周期内所有记录都写到一个文件中，所以需要数据成员fd。
	又想让它全局唯一，所以把它设计成一个单例模式（Singleton），只能创建一个对象。因为要让 static GetInstance()不通过对象访问，
	所以要把 m_pLogger写成static的。
	单例模式要全局只能创建一个对象，那么构造函数，拷贝构造函数，赋值运算符，析构函数就不能被类外部访问，只能由类本身来控制。
	构造，拷贝构造，赋值运算符都不能被外部访问，那么怎么创建一个对象呢？答案是通过用一个类的函数：static CLLogger * GetInstance();
	有了单例模式来创建对象，每次写日志的时候都需要GetInstance，然后再调用WriteLog写比较麻烦，所以向通过一个封装函数，直接写。
	
	Version 0.2:有缓冲
	功能:为了减少磁盘读写，加快速度，有两种方法：一减少write调用次数，减少陷入内核；二尽量顺序写（已满足）。在Version 0.1基础上加入缓冲。
	task list:加入缓冲
	怎样描述一个缓冲区呢？首先，要给缓冲区指派一个存储空间，用一个指针指向其起始地址；其次，缓冲区有大小size，已用空间大小used，剩余空间大小empty，
	当前写入位置（用 缓冲区size-已用空间used 即可）。
	需要增加刷新缓冲的函数：Flush()；
	此版利用不同的缓冲区大小,进行了性能测试，见measuring_efficiency_main.cpp。
	
	Version 0.3:程序退出时刷缓冲问题
	问题：1.之前版本程序退出前，必须有库使用者手动flush缓冲才能避免缓冲丢失，不方便使用。希望退出时自动清理缓冲。
		 2.main返回后并不意味着程序运行结束了，全局对象的析构函数才刚开始。若这些对象的析构中调用了WriteLogMesg则这写数据扔会保留在缓冲中。.
	解决方案：
		1.用atexit函数。在单例模式创建对象的时候注册一个OnProcessExit函数进行刷缓冲。注意：因为atexit函数规定了注册函数的原型，且要符合c语言默认
		调用约定（函数参数从右到左压栈，并由调用者清栈），若是成员函数，则多出来了this指针，不符合注册函数原型要求，所以OnProcessExit应该是一个静态
		static函数成员函数。
		方案1存在的问题：atexit注册的函数并没有说明全局对象的析构函数同同注册函数间的调用先后顺序关系，不保证能处理析构全局对象时写的日志（实际上不能处理）。
		2.Improve slution.既然可能在调用OnProcessExit后还可能写日志到缓冲，那么我们就设置一个标志flag，当调用OnProcessExit后只能用无缓冲的写。
		3.
		
		
	c++语法：
	static数据成员要显式初始化，需要写类型，如 int CLLogger::m_Fd = -1。
	在类声明中写了static，在定义时不必写static.
	在static成员函数中访问非静态成员必须要通过对象访问，访问静态成员则不用。因为static成员是属于整个类的。
	
	c++ style:
	if( -1 == w )，一定要不左值放在右边，防止不小心写成 if( w = -1)，避免错误
	程序结束后用CLStatus返回执行状态并进行检查是个好习惯！很有必要！避免错误。