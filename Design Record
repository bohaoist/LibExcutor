Design Principle

General Pourpose:学习设计模式，学习封装Linux API，练习C++
Method：先看书，然后把书放在一边，自己设计，自己实现！（自己做很重要！照着书上敲代码很多时候是敲了也不知道别人为什么那样做！）

CLStatus:
	功能：用来反应函数执行完的状态，包括返回值和出错码。
	为了使得类外部可以直接使用变量名返回出错码 m_lErrorCode, 使用了两个public的const long &引用来实现外部只可以读不可写。
	直接 return CLStatus()对象会减少构造对象的次数，提高效率，故这样写。不要CLStatus A; return A；，这样会增加构造次数。

CLLogger:
	功能：每条日志包含一条日志消息和一个出错码。
	
	Version 0.1：无缓冲
	CLLogger是一个记录程序出错的日志类，需要读写文件。由于一个程序生命周期内所有记录都写到一个文件中，所以需要数据成员fd。
	又想让它全局唯一，所以把它设计成一个单例模式（Singleton），只能创建一个对象。因为要让 static GetInstance()不通过对象访问，
	所以要把 m_pLogger写成static的。
	单例模式要全局只能创建一个对象，那么构造函数，拷贝构造函数，赋值运算符，析构函数就不能被类外部访问，只能由类本身来控制。
	构造，拷贝构造，赋值运算符都不能被外部访问，那么怎么创建一个对象呢？答案是通过用一个类的函数：static CLLogger * GetInstance();
	有了单例模式来创建对象，每次写日志的时候都需要GetInstance，然后再调用WriteLog写比较麻烦，所以向通过一个封装函数，直接写。
	
	Version 0.2:有缓冲
	功能:为了减少磁盘读写，加快速度，有两种方法：一减少write调用次数，减少陷入内核；二尽量顺序写（已满足）。在Version 0.1基础上加入缓冲。
	task list:加入缓冲
	怎样描述一个缓冲区呢？首先，要给缓冲区指派一个存储空间，用一个指针指向其起始地址；其次，缓冲区有大小size，已用空间大小used，剩余空间大小empty，
	当前写入位置（用 缓冲区size-已用空间used 即可）。
	WriteLog的时候，对要写的消息和缓冲区大小，剩余大小的判断顺序很重要！采用从大到小的顺序原则进行判断。先判断要的写消息是否大于缓冲区大小，若是则直接写入；若否，则再判断
	要写入的消息是否大于缓冲区剩余空间，若是则刷新；若否，则直接写入缓冲区。
	需要增加刷新缓冲的函数：Flush()；
	此版利用不同的缓冲区大小,进行了性能测试，发现一个合适的缓冲区大小直接影响着性能，见measuring_efficiency_main.cpp。
	
	Version 0.3:程序退出时刷缓冲问题
	问题：1.之前版本程序退出前，必须有库使用者手动flush缓冲才能避免缓冲丢失，不方便使用。希望退出时自动清理缓冲。
		 2.main返回后并不意味着程序运行结束了，全局对象的析构函数才刚开始。若这些对象的析构中调用了WriteLogMesg则这写数据扔会保留在缓冲中。.
	解决方案：
		1.用atexit函数。在单例模式创建对象的时候注册一个OnProcessExit函数进行刷缓冲。注意：因为atexit函数规定了注册函数的原型，且要符合c语言默认
		调用约定（函数参数从右到左压栈，并由调用者清栈），若是成员函数，则多出来了this指针，不符合注册函数原型要求，所以OnProcessExit应该是一个静态
		static函数成员函数。
		方案1存在的问题：一、atexit注册的函数并没有说明全局对象的析构函数同同注册函数间的调用先后顺序关系，不保证能处理析构全局对象时写的日志（实际上不能处理）。
		二、如果由atexit注册的其他函数需要写日志，也无法保证能正确的刷缓冲。
		2.Improving slution：既然可能在调用OnProcessExit后还可能写日志到缓冲，那么我们就设置一个标志flag，当调用OnProcessExit后只能用无缓冲的写。
		3.如果程序是非正常退出，如异常try，进程调用_exit函数,_EXIT等，由atexit注册的函数都不会被调用。这些情况就只能由程序库用户自己手动刷新了。
		
线程的封装：
	内容：包括线程的创建、同步、线程之间的通信等。其中通信部分参考Windows的线程消息队列机制。
线程创建的封装：
	编译问题：pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a，所以在使用pthread_create()创建线程，以及调用 pthread_atfork()函数建立fork
	处理程序时，需要链接该库。在编译中要加 -lpthread参数：gcc thread.c -o thread -lpthread。projects->properties->c/c++ builder->toolssetting->
	libraries->add填写pthread，不要在前面加-l。
	
	系统API：#include <pthread.h>
			int pthread_create(pthread_t *restrict tidp,
		                   const pthread_attr_t *restrict attr,
		                   void *(*start_rtn)(void), 
		                   void *restrict arg);
			Returns: 0 if OK, error number on failure。成功返回0，失败返回错误码。不像其他一些API返回0表示正确，-1表示错误，而出错码要通过全局变量errno获得，然后再用strerror()函数获得具体含义。
			pthread_t是存储线程ID的类型，定义为typedef unsigned long int pthread_t。参数中指针pthread_t *表面在调用前用先创建一个tidp。
	
	等待线程死亡并收回状态资源：主线程如果退出，不管其他线程是否在运行，都一律终止，整个进程也终止。所以需要用到等待线程死亡并收回线程状态所占用的资源：pthread_join。
	调用它的线程会进入阻塞状态。
	终止时自动收回所占资源：pthread_detach。若调用了pthread_detach后再调用phtread_join，则后者会返回EINVAL错误。
	
	标*的为比较重要的封装方法。
	
	基于对象的方法封装：（缺点：无法封装变化点）
	用一个Run函数来封装pthread_create即可。
	static void *StartFunctionOfThread(void *pContext)作为所有线程的统一入口，用来包装其他线程的业务逻辑函数RunThreadFunction，用户只需要实现这个业务逻辑即可。
	它要是静态成员函数。原因和OnProcessExit一样，	应为pthread_create规定了函数原型，普通成员函数默认含有this指针。按照c语言默认调用约定_cdecl,所以应该是静态成员函数，以满足原型要求。
	因为StartFunctionOfThread是静态的，所以没有this。但又想在其中使用数据成员，故要把this当做参数传递进去。
	这种方法的缺点是要改变业务逻辑函数RunThreadFunction，就要修改CLThread类，破坏了封装性。
	
	*面向对象的方法封装：（缺点：派生的业务逻类辑的实现依赖于现有基类和基类中的虚函数定义，基类不能变，虚函数接口必须遵循基类实现）
	本方法属于基于虚函数的，动态的面向对象方式。下面基于模板的是静态的面向对象思想。
	思想：把需要变化的不同点，通过多态（虚函数）和继承来解决。不变的部分作为基类。用派生类来封装不同的业务逻辑，即每一个新业务，只需要实现一个派生类即可。
	在基于对象的方法基础上，讲原来的业务逻辑函数变成纯虚函数:protected：virtual CLStatus RunThreadFunction()=0；新创建的业务类型只需要继承CLThread并实现其业务逻辑就可以了。
	同时，析构函数也要变成虚函数virtual ~CLThread()，二是数据成员变成protected，便于派生类访问。
	存在的问题：继承关系将会使派生类耦合于基类的接口，耦合于基类的实现，即派生类依赖于基类。耦合于接口指派生类的虚函数都要遵循基类中这个虚函数的定义。耦合于基类实现指这些业务逻辑和现有
	基类固定搭配，如果换了其	他基类则不能重复利用现有业务逻辑代码了。如果现在需求变了，要求以创建进程的方式来执行这些业务逻辑，如何才能把这些单独实现的业务逻辑再次重复利用呢？
	
	*基于接口的方法封装：（优点：容纳业务逻辑和执行方式两个变化点，只耦合于基类的接口，不耦合于基类的实现）
	拆分成两部分：1.业务逻辑。2.执行方式（线程 OR 进程）
	变化点：1.需要执行的业务逻辑由多种可能。2.执行业务逻辑的方式可能变化，即创建进程来执行还是创建线程来执行，可能变化。
	解决思路：有变化点，就（适当）抽象出一个继承体系来。将两个变化点分别抽象成一个更高层次的基类，变化的部分由派生类来具体实现。然后通过传递参数的方式讲二者组合起来。
	通过用参数传递的方式代替继承的方式来解决派生业务逻辑类耦合于基类实现的问题，如explicit CLExecutive(CLExcutiveFunctionProvider *pExecutiveFunctionProvider);将业务和执行方式独立。
	使用方法：{CLExecutiveFunctionProvider* printer = new CLParaPrinter();CLExecutive *pThread = new CLThread(printer);}
	指针是使用了基类的指针，具体创建new的时候是创建了派生类的对象。通过传递参数的方法来讲二者结合起来，解决业务逻辑耦合于执行方式（线程 OR 进程）的问题。
	
	基于模板的面向对象程序设计思想：（静态的面向对象，模板的第一种范式）
	本方法属于基于模板的，静态的面向对象的方式。与前面基于虚函数的动态面向对象不同，本方法通过模板参数来传递实际运行对象。
	思路：与用虚函数不同，业务继承基类，同时将需要变化的业务自身通过模板参数传递给基类，使之实例化具体要调用的方法。
	
	面向方面的程序设计思想：（模板的第二种范式，略复杂，可以装配（改变或控制）流程，更加灵活）
	思想：执行方式（进程或线程）和业务逻辑是两个方面，通过一个模板协调器类将二者结合起来，协同工作，次协调类是两个方面的派生类。这样可以分别实现二者。一个模板参数就代表了一个方面，
	而一个方面实际上就是对一类问题，即变化点的抽象。通过协调类来控制代码在CLThread还是CMyFunction中执行，具体实现是通过强制转换来实现基类和派生类之间的跳转。
	自始至终都在一个对象中运行，但由于要执行不同的功能，故要在基类和派生类之间转来转去。
	首先在main函数中创建协调器对象，参数存在协调器对象里，然后先要创建线程，故先将this（CLCoordinator）转为创建线程的TExecutive类。创建线程时由于需要用到线程入口函数，进入
	封装的入口函数后要执行真正的业务逻辑，而只有协调器才知道怎么执行业务逻辑，故又需要将this强转回协调器类（Coordinator），	调用业务逻辑函数，并利用其中的参数来执行业务逻辑函数。
	不断的从各种基类和派生类之间转来转去反应了程序的控制流程的变化，以协调器为中心，分别跳到创建进程和创建业务逻辑的基类中，执行完再通过强制类型转换从基类中跳回到协调器类中。
	赋予模板参数的过程称为装配。当业务流程变了，不是先创建线程再紧接着执行业务逻辑，而是创建线程后先做一些其他事，再执行业务逻辑，那么可以重写一个协调器类将执行体和业务装配起来，
	只要在ProcessByProxy中先做其他事情，再调用业务逻辑即可。
	
	*基于接口的程序设计思想再封装：（新变化点：业务流程可能发生改变）
	要解决的问题：第三个变化点：业务流程的变化，即先创建执行体然后再执行业务逻辑这一流程可能发生改变。（1.执行方式变化。2.业务变化）
	思路：结合面向方面的思想，只是面向方面用模板参数来装配流程，而面向接口的思想用函数参数来装配流程。加入一个协调器来控制业务流程，其中数据成员分别是执行方式的指针和业务指针。
	同时，为了封装不同的流程，弄一个协调器的继承体系出来。同时，为了控制执行流，在执行体类和业务类中要加入指向协调器的指针。Run的时候，先用协调器通过excutive指针建立线程，建立后
	再用线程和协调器的指针，将程序控制流转移到协调器中，然后再由协调器的ReturnControlRight调用业务逻辑。
	使用方法：
	CLCoordinator *pCoordinator = new CLRegularCoordinator();
	CLExecutiveFunctionProvider * printer = new CLParaPrinter();
	CLExecutive *pThread = new CLThread(pCoordinator);
	pCoordinator->SetExecObjects(pThread,printer);
	pCoordinator->Run((void*)2000);
	pCoordinator->WaitForDeath();
	
线程同步的封装：
	几个问题：声明是线程同步？为什么需要线程同步？什么是死锁？如何避免死锁？
	互斥锁：pthread库提供了互斥量的机制，互斥量实际是一把锁。当一线程需要访问共享资源时，首先需要进行加锁。pthread库中要使用互斥量首先要初始化它，使用完毕还要销毁它。
	互斥锁API：pthread_mutex_inti，pthread_mutex_destroy，pthread_mutex_lock(默认会阻塞),pthread_mutex_unlock，pthread_mutex_trylock。调用成功时返回0，出错时返回错误码。
	其中，如互斥量已经被加锁，若有其他线程再调用pthread_mutex_lock加锁，则会阻塞。用pthread_mutex_trylock则不会阻塞，返回EBUSY。这几个函数成功时返回0，出错时返回出错码。
	加锁流程：
		1.初始化一个pthread_mutex_t类型的互斥量。
		2.调用pthread_mutex_init函数对互斥量进行初始化。
		3.访问共享资源前用pthread_mutex_lock或trylock解锁。
		4.访问共享资源
		5.访问完共享资源，用pthread_mutex_unlock解锁
		6.当不需要互斥量的时候，用pthread_mutex_destroy函数销毁互斥量。
	
	线程安全版本的CLLogger类：
	不安全的表现：1.写日志时不安全，若在Flush的时候后，已用缓存标记未置为0前有数据写入缓冲区，则置为0后这部分信息就会被丢失。
	2.创建CLLogger类对象时不安全，若在创建了一半赋值个对象指针m_pLogger前被中断，则会导致可能创建多个对象，而只有一个指针，造成内存泄露。当多个线程都在调用WriteLogMsg函数记录的日志时，
	这些线程都有可能同时向CLLogger的缓存写入日志信息。
	注意：分清楚哪些是多线程共享区！然后才能利用合适的锁。相同的共享区用同一把锁。1.创建唯一的单例对象是共享区，需要加锁。2.涉及到缓冲区的部分是共享区，对共享变量的操作都要加锁。
	对不同的区域要不同的锁，所以要两把锁。锁——其实是对执行流的一种控制，执行流的一种阻滞，一种停滞，让某一段执行流必须只能单个线程通过，不能拥挤。
	性能：为了提高性能，将if(CLLogger::m_pLogger != NULL)放在第一行，直接判断对象是否创建成功。而不用等待加锁了之后再去判断。这会不会造成不一致的情况呢？即创建对象的时候写了一半
	就被中断，而另一个在此时读。不可能。因为通常情况下，读写一个对齐了的数据，都能在一个总线周期内完成。将一个地址值写入m_pLog或从m_pLog读出地址值，是不会被中断的。目前的版本无论是直接往文件
	写日志信息还是往缓存中写日志信息，都需要进行同步，而一同步就会影响程序性能。如何尽量减少同步时间呢？一种方案是：每个线程都由自己的日志缓存；每次写日志都直接写入自己独享的缓存中。当缓存满时可以
	同步刷缓存，或者把刷缓存任务交给某个独立的线程进行。
	bug：目前的版本还存在一个bug，就是如果线程B获得日志对象指针后，在线程A完成atexit函数调用、以及m_bFlagForProcessExit标志赋值之前就执行了写日志操作，那么存入缓存中的日志信息就有
	可能丢失。
	
	CLMutex：封装互斥量
	将互斥量初始化和销毁分别放在构造函数和析构函数中。对外提供接口有Lock和Unlock，用来加锁和解锁。但是如果直接拿来用CLMutex，可能涉及到要处理异常并解锁，则会很复杂。
	CLCriticalSection将CLMutex对象包装起来，利用局部对象的生存周期，随着CLCriticalSection对象建立而加锁，销毁而解锁，这样自动实现加锁和解锁。
	
	
	
	
	
	
	
	
	
	